package atomos

import (
	"errors"
	"github.com/golang/protobuf/proto"
	"log"
	"os"
	"os/signal"
	"plugin"
	"sync"
	"syscall"
)

var ErrAtomTypeNotExists = errors.New("atomos: atom type not exists")
var ErrAtomNameExists = errors.New("atomos: atom name exists")
var ErrAtomNameNotExists = errors.New("atomos: atom name not exists")
var ErrAtomCallNotExists = errors.New("atomos: atom call not exists")
var ErrAtomHalt = errors.New("atomos: atom halt")
var ErrCustomizeAtomType = errors.New("atomos: customize atom type illegal")

// Atom
// Atomos is atom. Atomos refer in particular to framework name, and Atom is a concrete type.
// Atomos就是Atom。这里的Atomos更多是指这个框架的名字，而Atom指的是具体的类型。
// Developer implements the interface "Atom", and let Cosmos spawn it.
// 开发者实现Atom接口，然后用Cosmos来让它运转。

type Atom interface {
	Spawn(self AtomController, data []byte)
	Save() []byte
}

// Callable is an interface generated by protoc-gen-go-atomos. Developer can call atom with it.
// Callable是一个由protoc-gen-go-atomos工具生成的接口。开发者可以使用它来调用atom。

type Callable interface {
	Close() error
}

type CosmosNode interface {
	GetAtomCallable(desc *AtomTypeDesc, name string) (Callable, error)
	CallAtom(aType, aName, cName string, args proto.Message) (reply proto.Message, err error)
	CloseAtom(aType, aName string) error
}

type BoostrapFn func() error

// Cosmos
// Cosmos is universe, universe is the container of atoms
// 简单地说，Cosmos就是宇宙，宇宙就是原子的容器

type Cosmos struct {
	mu  sync.Mutex
	cfg CosmosConfig
	ds  *dataStorage
	ats atomTypes
	n   *nodes
	url string
}

type CosmosConfig struct {
	CosmosId string
	Node     string
	// data
	DataFilepath string
	// grpc
	ListenNetwork string
	ListenAddress string
	ConnHeartBeat uint
	ConnHeadSize  int
	// etcd
	EtcdEndpoints   []string
	EtcdUsername    string
	EtcdPassword    string
	EtcdDialTimeout int64
	EtcdTTL         int64
}

func NewCosmos(conf CosmosConfig, atomTypeDesc ...*AtomTypeDesc) (*Cosmos, error) {
	c := &Cosmos{
		mu:  sync.Mutex{},
		cfg: conf,
		ats: map[string]*atomType{},
		ds:  &dataStorage{},
		n:   &nodes{},
	}
	if err := c.ds.open(conf.DataFilepath); err != nil {
		return nil, err
	}
	if err := c.n.init(c, atomTypeDesc...); err != nil {
		return nil, err
	}
	return c, nil
}

// Local

func (c *Cosmos) Register(desc *AtomTypeDesc) (err error) {
	c.ats.addType(desc)
	c.n.toUpdate = true
	return nil
}

func (c *Cosmos) Run() {
	// Signal
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	// Command
	cmdCh := make(chan string)
	// Loop
	exit := false
	for !exit {
		select {
		case s := <-sigCh:
			log.Println("Exit:", s)
			exit = true
		case c := <-cmdCh:
			log.Println("Cmd:", c)
		}
	}
}

func (c *Cosmos) loadPlugin(path string) {
	p, err := plugin.Open(path)
	if err != nil {
		log.Println("Cannot open plugin")
		return
	}
	boostrap, err := p.Lookup("Boostrap")
	if err != nil {
		log.Println("Cannot find boostrap function in plugin")
		return
	}
	fn, ok := boostrap.(BoostrapFn)
	if !ok {
		log.Println("Illegal boostrap in plugin")
		return
	}
	if err = fn(); err != nil {
		log.Println("Execute boostrap error,", err)
		return
	}
}

func (c *Cosmos) Close() {
	log.Println("closing cosmos")
	c.n.etcdUnregisterNode(c.url)
	// todo stop context
}

func (c *Cosmos) GetAtomCallable(desc *AtomTypeDesc, name string) (Callable, error) {
	t := c.ats.getType(desc.Name)
	if t == nil {
		return nil, ErrAtomTypeNotExists
	}
	if !t.has(name) {
		return nil, ErrAtomNameNotExists
	}
	return desc.NewCallable(c, name), nil
}

// Consider about hot reload
func (c *Cosmos) SpawnAtom(desc *AtomTypeDesc, name string, atom Atom) (Callable, error) {
	log.Printf("SpawnAtom(%q)", desc.Name)
	c.mu.Lock()
	defer c.mu.Unlock()

	t := c.ats.getType(desc.Name)
	if t == nil {
		return nil, ErrAtomTypeNotExists
	}
	if t.has(name) {
		return nil, ErrAtomNameExists
	}

	aw, err := t.init(c, name, atom)
	if err != nil {
		return nil, err
	}
	go aw.loop()
	return desc.NewCallable(c, name), nil
}

func (c *Cosmos) CallAtom(aType, aName, cName string, args proto.Message) (reply proto.Message, err error) {
	typeInfo, has := c.ats[aType]
	if !has {
		return nil, ErrAtomTypeNotExists
	}
	return typeInfo.call(aName, cName, args)
}

// todo delete from cosmos
func (c *Cosmos) CloseAtom(aType, aName string) error {
	typeInfo, has := c.ats[aType]
	if !has {
		return ErrAtomTypeNotExists
	}
	return typeInfo.close(aName)
}

// Remote Cosmos

func (c *Cosmos) GetRemoteCosmos(node string) *remoteNode {
	return c.n.remote[node]
}

func (r *remoteNode) GetAtomCallable(desc *AtomTypeDesc, name string) (Callable, error) {
	log.Println("remoteNode.GetAtomCallable")
	_, has := r.Types[desc.Name]
	if !has {
		return nil, ErrAtomTypeNotExists
	}
	// todo find remote actor
	exist, err := r.sendGetAtomReq(r.CosmosData.Node, desc.Name, name)
	if err != nil {
		return nil, err
	}
	if !exist {
		return nil, ErrAtomNameNotExists
	}
	return desc.NewCallable(r, name), nil
}

func (r *remoteNode) CallAtom(aType, aName, cName string, args proto.Message) (reply proto.Message, err error) {
	// todo send remote actor
	return nil, nil
}

// Inner

func (c *Cosmos) getCosmosData() *CosmosData {
	d := &CosmosData{
		CosmosId: c.cfg.CosmosId,
		Node:     c.cfg.Node,
		Network:  c.cfg.ListenNetwork,
		Addr:     c.cfg.ListenAddress,
		Types:    map[string]*AtomType{},
	}
	for typeName, typeInfo := range c.ats {
		var f []string
		for funcName, _ := range typeInfo.calls {
			f = append(f, funcName)
		}
		d.Types[typeName] = &AtomType{
			Name: typeName,
			Func: f,
		}
	}
	return d
}
