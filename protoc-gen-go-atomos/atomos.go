package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	atomosPackage = protogen.GoImportPath("atomos")
	protobufPackage = protogen.GoImportPath("github.com/golang/protobuf/proto")
)

// generateFile generates a _grpc.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_atomos.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-atomos. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the gRPC service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the grpc package it is being compiled against.")
	g.P()
	for _, service := range file.Services {
		genCallable(gen, file, g, service)
		genAtomos(gen, file, g, service)
		genDesc(gen, file, g, service)
	}
}

func genCallable(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	callableName := service.GoName + "Callable"

	g.P("// ", callableName, " is the callable API for ", service.GoName, " atomos.")
	g.P("//")

	// Callable interface.
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	g.Annotate(callableName, service.Location)
	g.P("type ", callableName, " interface {")
	g.P(atomosPackage.Ident("Callable"))
	for _, method := range service.Methods {
		g.Annotate(callableName+"."+method.GoName, method.Location)
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading,
			callableSignature(g, method))
	}
	g.P("}")
	g.P()

	// Callable structure.
	g.P("type ", noExport(callableName), " struct {")
	g.P("world ", atomosPackage.Ident("CosmosNode"))
	g.P("name string")
	g.P("}")
	g.P()

	// NewClient factory.
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P("func Get", callableName, " (c ", atomosPackage.Ident("CosmosNode"), ", name string) (", callableName, ", error) {")
	g.P("ca, err := c.GetAtomCallable(&", descName(service.GoName), ", name)")
	g.P("if err != nil { return nil, err }")
	g.P("if c, ok := ca.(", callableName, "); ok { return c, nil } else { return nil, ", atomosPackage.Ident("ErrCustomizeAtomosType"), " }")
	g.P("}")
	g.P()

	// Client method implementations.
	for _, method := range service.Methods {
		genAtomosCall(gen, g, method)
	}
	g.P()
	g.P("func (c *", noExport(callableName), ") Close() error {")
	g.P("return c.world.CloseAtom(\"", service.GoName, "\", c.name)")
	g.P("}")
	g.P()
}

func callableSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	return method.GoName + "(in *" +
		g.QualifiedGoIdent(method.Input.GoIdent) + ") (*" +
		g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
}

func genAtomosCall(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) {
	service := method.Parent
	callableName := service.GoName + "Callable"
	g.P("func (c *", noExport(callableName), ") ", callableSignature(g, method), " {")
	g.P("r, err := c.world.CallAtom(\"", service.GoName, "\", c.name, \"", method.GoName, "\", in)")
	g.P("if err != nil { return nil, err }")
	g.P("reply, ok := r.(*", method.Output.GoIdent, ")")
	g.P("if !ok { return nil, ", atomosPackage.Ident("ErrAtomosCallableMethod"), " }")
	g.P("return reply, nil")
	g.P("}")
	g.P()
}

func genAtomos(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	// Server struct.
	atomosType := service.GoName + "Atomos"
	callableName := service.GoName + "Callable"
	g.P("// ", atomosType, " is the atomos API for ", service.GoName, " atomos.")
	g.P("//")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	g.Annotate(atomosType, service.Location)
	g.P("type ", atomosType, " interface {")
	g.P(atomosPackage.Ident("Atomos"))
	for _, method := range service.Methods {
		g.Annotate(atomosType+"."+method.GoName, method.Location)
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading,
			callableSignature(g, method))
	}
	g.P("}")
	g.P()

	g.P("func Spawn", atomosType, "(c *", atomosPackage.Ident("Cosmos"), ", name string, atom ", atomosType, ") (",
		callableName, ", error) {")
	g.P("ca, err := c.SpawnAtom(&", descName(service.GoName), ", name, atom)")
	g.P("if err != nil { return nil, err }")
	g.P("if c, ok := ca.(", callableName, "); ok { return c, nil }")
	g.P("return nil, ", atomosPackage.Ident("ErrCustomizeAtomosType"))
	g.P("}")
}

func genDesc(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	callableName := service.GoName + "Callable"
	atomosType := service.GoName + "Atomos"
	g.P()
	g.P("var ", descName(service.GoName), " ", atomosPackage.Ident("AtomTypeDesc"), " = ", atomosPackage.Ident("AtomTypeDesc"), " {")
	g.P("Name: \"", file.GoPackageName, ".", service.GoName, "\",")
	g.P("NewCallable: func(c ", atomosPackage.Ident("CosmosNode"), ", name string) ", atomosPackage.Ident("Callable"), " {")
	g.P("return &", noExport(callableName), "{c, name}")
	g.P("},")
	g.P("Calls: []", atomosPackage.Ident("CallDesc"), "{")
	for _, call := range service.Methods {
		g.P("{")
		g.P("Name: \"", call.GoName, "\",")
		g.P("Func: func(atom ", atomosPackage.Ident("Atomos"), ", in ", protobufPackage.Ident("Message"), ") (", protobufPackage.Ident("Message"), ", error) {")
		g.P("req, ok := in.(*", call.Input.GoIdent, ")")
		g.P("if !ok { return nil, ", atomosPackage.Ident("ErrAtomosTypeNotExists"), " }")
		g.P("a, ok := atom.(", atomosType, ")")
		g.P("if !ok { return nil, ", atomosPackage.Ident("ErrAtomosTypeNotExists"), " }")
		g.P("return a.", call.GoName, "(req)")
		g.P("},")
		g.P("ArgDec: func(buf []byte) (", protobufPackage.Ident("Message"), ", error) {")
		g.P("r := &", call.Input.GoIdent, "{}")
		g.P("return r, ", protobufPackage.Ident("Unmarshal"), "(buf, r)")
		g.P("},")
		g.P("ReplyDec: func(buf []byte) (",  protobufPackage.Ident("Message"), ", error) {")
		g.P("r := &", call.Output.GoIdent, "{}")
		g.P("return r, ",  protobufPackage.Ident("Unmarshal"), "(buf, r)")
		g.P("},")
		g.P("},")
	}
	g.P("},")
	g.P("}")
}

const deprecationComment = "// Deprecated: Do not use."

func noExport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func descName(s string) string { return noExport(s) + "Desc" }
